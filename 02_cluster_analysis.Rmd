---
title: "02_cluster_analysis"
output: html_document
date: "2024-03-11"
---

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(scipen=999)

source("00_loads_packages.R")
source("01_loads_data.R")

```


## Select k-value for k_NN clustering
There are two ways to determine the optimal number of clusters (k-value); the gap statistic, and the within-cluster sum of square (WSS).

The gap statistic approach compares within-cluster distribution to a reference sample of the data.

WSS measures the internal variance of the clusters, and selects the number of clusters based on the point at which adding more clusters does not significantly decrease the internal variance, indicating that optimal clustering has been reached.

```{r gap_wss}

optimal_clusters_gap <- fviz_nbclust(exmort_weekly_nuts3_wide %>% select(!code_nuts), kmeans, method = "gap_stat")

optimal_clusters_gap

optimal_clusters_wss <- fviz_nbclust(exmort_weekly_nuts3_wide %>% select(!code_nuts), kmeans, method = "wss")

print(optimal_clusters_wss)

```


## Trajectory clustering - k_NN & Affinity Propagation
We cluster the units on their excess mortality trajectories using Affinity Propagagation clustering, and assign them each a cluster affiliation.

A known limitation of the k-NN approach to clustering is its sensitivity to outliers, and noise. The weekly excess mortality data we use contains extreme outliers, such as the NUTS3 units in northern Italy and central Spain, where weekly excess mortality exceeded 600% during March 2020. The data may also be affected by inconsistencies in reporting standards, quality, and timeliness.

To address this limitation, we use an alternative method, Affinity Propagation (AP), to replicate and validate the results. 

```{r cluster, warning = FALSE}

#K-means
k_nuts <- exmort_weekly_nuts3_wide %>% select(code_nuts)
set.seed(12)
k_means <- kmeans(exmort_weekly_nuts3_wide %>% select(!code_nuts), 5, iter.max = 50, nstart = 1)
k_clust <- k_nuts %>% cbind(k_means$cluster)


# AP cluster
clustered_mort <- exmort_weekly_nuts3_wide %>% select(code_nuts)
mort_cluster <- apcluster(negDistMat(r=2), exmort_weekly_nuts3_wide %>% select(!code_nuts), q=0)





mort_exemplars <- integer(length(mort_cluster@exemplars)) 

for(i in seq_along(mort_cluster@exemplars)) {
  mort_exemplars[i] <- mort_cluster@exemplars[[i]][1]
}

mort_cluster_ids <- integer(mort_cluster@l)
for(i in seq_along(mort_cluster@clusters)) {
  cl <- mort_cluster@clusters[[i]]
  for(j in seq_along(cl)) {
    mort_cluster_ids[cl[j]] <- i
  }
}
  

clustered_mort <- clustered_mort %>%
  cbind(mort_cluster_ids) 


```


# Compare the two approaches
The two methods give broadly similar results, with only a few units reassigned.

When we generated 5 clusters from the data using AP with q = 0, we achieved broadly similar results to the k-NN analysis with k=5. Only 51 units out of 772 were reassigned by the change in algorithm. 
However, it was evident from the distribution of units between the clusters that the AP approach was less sensitive to the outliers in the data, and produced more useful, intuitive clusters. The k-NN clustering approach yielded one cluster containing only 15 units. Clustering with AP increased the size of this cluster to 27 units.



```{r compare, warning = FALSE, message=FALSE}

cluster_compare <- clustered_mort %>% 
  select(code_nuts, mort_cluster_ids) %>%
  mutate(cluster_type = "ap_cluster") %>%
  rbind(k_clust %>% 
          rename(mort_cluster_ids = `k_means$cluster`) %>%
          mutate(cluster_type = "k_means")) 

sizes <- cluster_compare %>%
  group_by(cluster_type, mort_cluster_ids) %>%
  summarise(count = n()) %>%
  arrange(cluster_type, count)


# Arrange by size order and give the same labels, to make them easier to read and compare
ap_order <- (sizes %>% filter(cluster_type == "ap_cluster"))$mort_cluster_ids
sizes$mapped <- rep(ap_order, length.out = nrow(sizes))

cluster_compare <- cluster_compare %>%
  left_join(sizes %>% select(mort_cluster_ids, cluster_type, mapped))


# Plot two maps to compare the difference between the two approaches
compare_map <- ggplot(cluster_compare %>%
         left_join(geodata)) +
  geom_sf(aes(fill = as.factor(mapped), geometry = geometry)) +
  geom_sf(data = geodata_0,
          aes(geometry = geometry), fill = NA, colour="black") +
  coord_sf(xlim = c(-10,32), ylim = c(36,72)) +
  scale_fill_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  bbc_style() +
  theme(panel.grid.major = element_blank(),
        legend.position = "right",
        axis.text = element_blank(),
        axis.text.x= element_blank()) +
  facet_wrap(~ cluster_type) +
  labs(title = "Compare cluster assignments")



# format data for a sankey chart
sankey_df <- cluster_compare %>%
  select(code_nuts, cluster_type, mapped) %>%
  pivot_wider(names_from = cluster_type, values_from = mapped) %>%
  rename(AP = ap_cluster,
         k_NN = k_means) %>%
  make_long(k_NN, AP)


sankey_df$node <- factor(sankey_df$node,levels = c(5,4,3,2,1))
sankey_df$next_node <- factor(sankey_df$next_node,levels = c(5,4,3,2,1))


sankey <- ggplot(sankey_df, aes(x = x,
               next_x = next_x,
               node = node,
               next_node = next_node,
               fill = factor(node))) +
  geom_sankey(flow.alpha = 0.82, node.color = 1) +
      scale_fill_manual(values = rev(c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")),
                        guide = guide_legend(reverse = TRUE) ) +
  theme_sankey(base_size = 16) +
  bbc_style() +
  theme(panel.grid.major.y = element_blank(),
        axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()) 


compare_map
sankey



```






# Final clustering results
We select AP as the clustering algorithm. Generate map for paper.

```{r exmort_by_cluster, warning = FALSE}

ggplot(clustered_mort %>%
         left_join(geodata)) +
  geom_sf(aes(fill = as.factor(mort_cluster_ids), geometry = geometry)) +
  geom_sf(data = geodata_0,
          aes(geometry = geometry), fill = NA, colour = "black", lwd = 0.6) +
  coord_sf(xlim = c(-10,32), ylim = c(36,72)) +
  scale_fill_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  bbc_style() +
  theme(panel.grid.major = element_blank(),
        legend.position = "right",
        axis.text = element_blank(),
        axis.text.x= element_blank(),
        legend.title = element_text(size = 16)) +
  labs(fill = "Cluster ID") +
  guides(fill = guide_legend(override.aes = list(colour = NA)))




cluster_compare_weekly_baseline_mort <- weekly_raw_mort_nuts3 %>%
  left_join(cluster_compare) %>%
  drop_na() %>%
  filter(year %in% c(2015, 2016, 2017, 2018, 2019)) %>%
  group_by(cluster_type, mapped, week) %>%
  summarise(expected_mort = (sum(raw_mort))/5)


# excess mortality by cluster
cluster_compare_weekly_exmort <- weekly_raw_mort_nuts3 %>%
  left_join(cluster_compare) %>%
  drop_na() %>%
  filter(year %in% c(2020, 2021),
         week < 53) %>%
  group_by(cluster_type, mapped, year, week) %>%
  summarise(clust_mort = sum(raw_mort)) %>% 
  left_join(cluster_compare_weekly_baseline_mort) %>%
  mutate(exmort = (clust_mort-expected_mort)/expected_mort,
         absolute_ex_mort = clust_mort - expected_mort,
         yearweek = as.numeric(paste0(year, week)),
         date = as.Date(paste0(year, "/", week, "/", 1), format ="%Y/%U/%u")) 



```



## Aggregating by cluster
Aggregating by cluster to generate their respective excess mortality trajectories shows the progress of COVID-19 in Europe through time and space. Four distinct pandemic waves can be identified during 2020 and 2021, although not every wave occurs in every cluster. By aggregating the excess mortality of NUTS3 units by cluster, we can see how these waves are spatially distributed.

```{r cluster_trajectories, warning = FALSE}

# Calculate baseline mortality - mean of previous five years
cluster_weekly_baseline_mort <- weekly_raw_mort_nuts3 %>%
  left_join(clustered_mort %>% select(code_nuts, mort_cluster_ids)) %>%
  drop_na() %>%
  filter(year %in% c(2015, 2016, 2017, 2018, 2019)) %>%
  group_by(mort_cluster_ids, week) %>%
  summarise(expected_mort = (sum(raw_mort))/5)

# excess mortality by cluster
cluster_weekly_exmort <- weekly_raw_mort_nuts3 %>%
  left_join(clustered_mort %>% select(code_nuts, mort_cluster_ids)) %>%
  drop_na() %>%
  filter(year %in% c(2020, 2021),
         week < 53) %>%
  group_by(mort_cluster_ids, year, week) %>%
  summarise(clust_mort = sum(raw_mort)) %>% 
  left_join(cluster_weekly_baseline_mort) %>%
  mutate(exmort = (clust_mort-expected_mort)/expected_mort,
         exmort_absolute = clust_mort-expected_mort,
        yearweek = as.numeric(paste0(year, week)),
        date = as.Date(paste0(year, "/", week, "/", 1), format ="%Y/%U/%u")) 


# Line chart of excess mortality aggregated by cluster
ggplot(cluster_weekly_exmort, aes(x = date, y = exmort, group = as.factor(mort_cluster_ids), colour = as.factor(mort_cluster_ids), fill = as.factor(mort_cluster_ids))) +
  geom_line(linewidth = 1) +
  geom_point(size = 0) +
  bbc_style() +
  scale_colour_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  scale_fill_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  # The fill is just to create a square legend

  scale_x_date(date_breaks = "4 months", date_labels=(date_format="%b %Y")) +
  scale_y_continuous(labels = percent) +
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 0.5),"cm"),
        legend.direction = "vertical",
        legend.position = c(.95, .65),
        legend.background = element_rect(fill = "white"),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        axis.text.x = element_text(size=12),
        axis.text.y = element_text(size = 12),
        axis.ticks.x = element_line(),
        axis.ticks.margin=unit(0,'cm'),
        panel.spacing = unit(2, "lines")) +
  guides(colour = guide_legend(override.aes = list(shape = 15, size = 7)),
         fill = "none") +
  labs(colour = "Cluster ID")



``` 
## Find peak dates and values
Identify peaks and the dates upon which they occur.

```{r identify_peaks}

# Identify highest exmort value for each cluster

cluster_weekly_exmort %>%
  group_by(mort_cluster_ids) %>%
  summarise(max_exmort = max(exmort),
            date_occurred = date[which.max(exmort)])


```

# Proportional impacts
The absolute numbers underlying the proportional excess mortality within these clustered groups put the wave dynamics and 'hotspot' outliers into context. Note that the weekly excess mortality estimates used in the analysis serve as a relatively crude indicator prioritizing pan-European comparability and do not represent actual counts.
```{r summary_figures_exmort, warning=FALSE}

# total baseline mortality by cluster i.e. mean value previous five years
pre_pando_mort_total_clust <- weekly_raw_mort_nuts3 %>%
  left_join(clustered_mort %>% select(code_nuts, mort_cluster_ids)) %>%
  drop_na() %>%
  filter(year %in% c(2015, 2016, 2017, 2018, 2019)) %>%
  group_by(mort_cluster_ids, year) %>%
  summarise(year_total = sum(raw_mort)) %>%
  group_by(mort_cluster_ids) %>%
  summarise(expected_biannual = 2*mean(year_total))


# total excess mortality by cluster
excess_mort_total_clust <- weekly_raw_mort_nuts3 %>%
  left_join(clustered_mort %>% select(code_nuts, mort_cluster_ids)) %>%
  drop_na() %>%
  filter(year %in% c(2020, 2021),
         week < 53) %>%
  group_by(mort_cluster_ids) %>%
  summarise(actual_mort = sum(raw_mort)) %>% 
  left_join(pre_pando_mort_total_clust) %>%
  mutate(exmort = (actual_mort-expected_biannual)/expected_biannual,
         exmort_number = actual_mort - expected_biannual)


# join population figures 
cluster_pop <- clustered_mort %>%
  left_join(population) %>%
  drop_na() %>%
  group_by(mort_cluster_ids) %>%
  summarise(pop = sum(pop19)) %>%
  left_join(excess_mort_total_clust) %>%
  pivot_longer(c(exmort_number, pop), names_to = "var", values_to = "value") %>%
  select(mort_cluster_ids, var, value)


cluster_pop_totals <- cluster_pop %>%
  group_by(var) %>%
  summarise(total = sum(value))

# format data for slope chart
slope_data <- cluster_pop %>%
  left_join(cluster_pop_totals) %>%
  mutate(percent = (value/total)*100,
         label = ifelse(var == "pop", paste0(round(percent, digits = 0), "%  "), paste0("  ", round(percent, digits = 0), "%")))

slope_data$var <- factor(slope_data$var, levels = c("pop", "exmort_number"))

slope <- ggplot(slope_data, aes(x = var, y = percent, label = label, group = mort_cluster_ids, colour = as.factor(mort_cluster_ids))) +
  geom_line(size = 2) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0, colour = "black") +
  bbc_style() +
  scale_x_discrete(labels = c("Share of\npopulation", "Share of\nexcess mortality")) +
  scale_colour_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  geom_text(aes(label = label, 
                hjust = ifelse(var == "pop", 1, 0)),
            colour ="black") +
  theme(axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        legend.direction = "vertical", 
        legend.position = c(0.95, 0.45),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12)) +
  guides(colour = guide_legend(override.aes = list(shape = 15, size = 9)),
         fill = "none") +
  labs(colour = "Cluster ID")

slope

```

# Absolute numbers
Generate a table of absolute numbers with sparklines.
The delay until November 2020 of the first wave in Clusters 4 and 5 makes the impact of the pandemic in these regions even more disproportionate. The temporal offset concentrates their elevated mortality burden within a shortened timeframe: 99% of the excess mortality impact in clusters 4 and 5 was incurred after October 10 2020.
```{r absolute_numbers}

table <- cluster_weekly_exmort %>%
  group_by(mort_cluster_ids) %>%
  arrange(date) %>%
  summarize(Trajectory = list(exmort), .groups = "drop") %>%
  left_join(excess_mort_total_clust %>% select(!c(actual_mort, expected_biannual ))) %>%
  mutate(exmort = label_percent()(round(exmort, digits = 2)),
         exmort_number = label_comma()(round(exmort_number, digits = 2))) %>%
  rename(Cluster = mort_cluster_ids,
         `Excess deaths` = exmort_number,
         `Excess mortality (%)` = exmort) %>%
  gt() %>%
  gt_theme_538() %>% 
  data_color(columns = Cluster, colors = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) %>%
  gt_plt_sparkline(Trajectory,
                   type = "shaded",
                   same_limit = FALSE, 
                   label = FALSE,
                   palette = c("black", "black", "transparent", "#C70039", "lightgrey"))


table

 
```
# Compound chart comparison -- Poland & Italy
Create chart showing ther trajectory variation and internally asymmetric mortality impact that is revealed by disaggregating the pandemic's weekly trajectory to NUTS3 level in Italy and Poland, and the distorting effect of aggregation on subnational mortality trajectories.
```{r poland_italy, warning = FALSE}


var_comp <- ggplot(exmort_weekly_nuts3 %>%
         # mutate(code_nuts = ifelse(grepl("DE", code_nuts), str_sub(code_nuts, 1, -3), code_nuts)) %>%
         left_join(clustered_mort) %>%
         drop_na() %>%
         mutate(country = substr(code_nuts, 1,2)) %>%
         filter(country %in% c("IT", "PL")) %>%
           mutate(country = ifelse(country == "PL", "Poland", "Italy")), 
       aes(x = date,
           y = exmort,
           group = code_nuts,
           colour = as.factor(mort_cluster_ids),
           fill = as.factor(mort_cluster_ids))) +
  geom_line(alpha = 0.2) + 
  scale_x_date(date_breaks = "1 year", date_labels=(date_format="%b/%y")) +
  scale_y_continuous(labels = percent) +
  geom_hline(yintercept = 0) +
  scale_colour_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  scale_fill_manual(values = c("#264653",
                                 "#2a9d8f",
                                 "#e9c46a",
                                 "#f4a261",
                                 "#e76f51")) +
  bbc_style() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        plot.title = element_text(size = 12),
        axis.text = element_text(size=8),
        strip.text.x = element_text(hjust = 0.5, size = 14),
        strip.placement = "outside") +
  labs(title = "Weekly excess mortality, NUTS3",
       colour = "Cluster ID") +
  guides(fill = guide_legend(override.aes = list(shape = 15, size = 7))) +
  facet_wrap(~country, strip.position = "bottom")

bar <- ggplot(total_excess_mort_nuts0 %>% filter(code_nuts %in% c("PL", "IT")), aes(x = reorder(code_nuts, exmort), y = exmort, fill = code_nuts)) + 
  geom_bar(stat = "identity") + 
  bbc_style() + 
  ylim(-0.2, 1.7) + 
  scale_y_continuous(labels = percent) +
  geom_hline(yintercept = 0) +
    scale_fill_manual(values = c("#8a5a96",
                                 "#f4a261")) +
  theme(legend.position = "none",
        plot.title = element_text(size = 12),
        axis.text.y = element_text(size = 8),
        axis.text.x = element_blank()) +
  labs(title = "Total excess mortality\n ")

line <- ggplot(excess_mort_nuts0 %>% filter(code_nuts %in% c("PL", "IT")), aes(x = date, y = exmort, colour = code_nuts)) + 
  geom_line() + 
  facet_wrap(~code_nuts) + 
  bbc_style()  + 
  ylim(-0.2, 1.5) + 
  scale_y_continuous(labels = percent) +
  scale_colour_manual(values = c("#8a5a96",
                                 "#f4a261")) +
  geom_hline(yintercept = 0) +
  theme(legend.position = "none",
        strip.text.x = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(size = 8),
        plot.title = element_text(size = 12)) +
  labs(title = "Weekly excess mortality")


combined_plot <- plot_grid(plot_grid(bar, line, var_comp, ncol = 1, rel_heights = c(1, 1, 2)))


ggsave("plt/combined_plot.png", plot = combined_plot, width = 8, height = 16, units = "cm")
combined_plot

```

# Anova test
Check for demographic correlations as per Lennart's feedback. Further correlation checks to follow.
```{r anova}

vars_clust <- read_csv("data/nuts3vars.csv") %>% left_join(clustered_mort)

aov(mort_cluster_ids ~ pop_dens, data = vars_clust) %>% summary()

kruskal.test(mort_cluster_ids ~ pop_dens, data = vars_clust)


aov(mort_cluster_ids ~ MEDAGEPOP, data = vars_clust) %>% summary()

kruskal.test(mort_cluster_ids ~ MEDAGEPOP, data = vars_clust)


ggboxplot(vars_clust, x = "mort_cluster_ids", y = "MEDAGEPOP")

```

